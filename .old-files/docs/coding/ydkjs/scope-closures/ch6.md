---
date: 2022-01-01
description: 번역 - Chapter 6 - Limiting Scope Exposure
---

# Chapter 6: Limiting Scope Exposure

::: tip
- [You Don't Know JS - 2nd Edition](https://github.com/getify/You-Dont-Know-JS "영문") 깃허브 공개 버전(영문)을 개인의 학습 목적으로 번역합니다.
- 한글 번역을 끝내면 핵심만 정리해 요약본으로 교체할 예정입니다.
- 전문 번역서는 [한빛미디어](https://www.hanbit.co.kr/media/books/book_view.html?p_code=B8227329776)에서 구입할 수 있습니다.
:::

[[toc]]

지금까지 스코프와 변수가 작동하는 방법을 설명해왔다. 단단한 해당 기초 지식을 가지고, 우리는 사고(예를 들어, 프로그램 전체에 걸처 적용하는 결정들과 패턴들) 수준을 더 높게 고양시킬 것이다.

우선, 우리는 프로그램 변수들을 구조화하기 위해(특히, 스코프 과노출을 줄이기 위해) 스코프 (함수 또는 블록)의 다른 레벨들을 사용해야 하는 이유와 방법에 대해 살펴보려 한다.

## Least Exposure

함수가 자신이 소유한 스코프를 정의하는 것은 의미가 있다. 그러나 스코프 생성을 위해 블록이 필요한 이유가 뭘까?

소프트웨어 엔지니어는 (일반적으로 소프트웨어 보안에 적용되고, ["The Principle of Least Privilege" (POLP)](https://en.wikipedia.org/wiki/Principle_of_least_privilege)로 불리는) 기초 원리를 분명히 한다. 그리고 우리의 현재 논의에 적용되는 이 원리는 일반적으로 "Least Exposure" (POLE)라고 명명된다.

:::tip Principle of Least Privilege란?
"굳이 직역하자면 최소 권한의 원칙(?)일 것 같고 풀어서 말하자면 특정 임무를 수행하는 객체에 그 특정 임무를 수행하는데 꼭 필요한 최소한의 권한만 부여 및 허용하는 방법론입니다."

출처: [Principle of Least Privilege with IAM Policy - Medium](https://medium.com/saltware/principle-of-least-privilege-with-iam-policy-454faa566f9b)
:::

POLP는 소프트웨어 아키텍처의 방어적인 자세를 표현한다. 이를 테면, 시스템의 컴포넌트는 최소 권한, 최소 액세스, 최소 노출로 기능하도록 디자인되어야 한다. 만약 각 부분(시스템의 부분)이 최소 필요 기능으로 연결된다면, 한 부분의 협업 또는 실패가 나머지 시스템에 최소한의 영향을 미치므로 전체 시스템은 보안 관점에서 더 강력하다.

만약 POLP가 시스템 수준의 컴포넌트 디자인에 집중한다면, POLE *노출* 변종은 더 낮은 수준에 집중한다. 우리는 스코프들이 상호작용하는 방법에 이것을 적용할 것이다.

다음 POLE에서, 우리가 노출의 최소화를 원하는 것은 무엇일까? 간단하게 변수들은 각 스코프에 등록된다.

다음을 생각해 보자. 어째서 사람들은 프로그램의 모든 변수들을 간단히 전역 스코프에 놓으면 안될까? 아마 나쁜 생각이라는 느낌이 즉시 들었을 것이다. 하지만 그 이유를 생각해 볼만한 가치가 있다. 프로그램의 한 부분에서 사용되는 변수들이 스코프를 통해 프로그램의 다른 부분에 노출되면 3가지 주요 문제점이 종종 발생한다.

- 이름짓기 충돌(Naming Collisions): 프로그램 내 2개의 다른 파트에서 공통적이고 유용한 변수/함수 이름을 사용한다면 식별자는 (전역 스코프와 같은) 하나의 공유 스코프에서 유래하고 이름 충돌이 발생한다. 그리고 다른 파트가 의도하지 않은 방법으로 변수/함수를 사용한 한쪽 파트에서 버그가 발생하기 매우 쉽다.

  예를 들어, 모든 루프가 인덱스를 위해 하나의 `i` 전역 변수를 사용한다면, 한 함수 안의 루프는 다른 함수 안의 루프가 반복할 때 실행하는 일이 발생한다. 그리고 공유된 `i` 변수는 의도치 않은 값을 갖는다.

- 의도하지 않은 행위(Unexpected Behavior): 프로그램의 한 부분을 위해 *비공개적*으로 사용하는 변수/함수를 노출한다면, 다른 개발자들이 의도하지 않은 방법으로 그 변수/함수를 사용할 수 있다. 이것은 의도한 행위를 위반하고 버그를 유발할 수 있다.

  예를 들어, 프로그램에서 당신의 코드는 모든 숫자들을 포함한 배열이 있다고 가정하자. 그런데 다른 누군가의 코드가 접속한 뒤 그 배열을 문자열과 불린 값을 포함하도록 수정한다면 이때 당신의 코드는 의도하지 않은 방법으로 오작동을 일으킬 것이다.

  더 심각한 것은, *비공개* 세부 정보의 노출은 당신이 부과했던 제한을 피해 작업을 시도하고, 허용되지 않은 소프트웨어의 일부로 일하는 나쁜 의도를 가진 사람들을 유인한다.

- 의도하지 않은 의존성(Unintended Dependency): 만약 불필요한 변수/함수를 노출한다면, *비공개* 자료 이외에 그 변수/함수를 사용하고 의존하는 다른 개발자들을 유도한다. 그것이 당장 당신의 프로그램을 망가트리지 않겠지만, 향후 리팩토링 문제를 발생한다. 왜냐하면 당신이 콘트롤하지 못하는 소프트웨어의 다른 부분들을 망가트릴 잠재적 위험 없이 당장 변수나 함수를 쉽게 개선할 수 없기 때문이다(cannot as easily refactor).

  예를 들어, 만약 당신의 코드가 숫자들의 배열에 의존하다가 나중에 배열 대신 다른 데이터 구조를 사용하는 것이 더 낫다고 판단한다면, 당신은 당장 영향을 받는 그 소프트웨어의 다른 일부를 조절하는 데 책임져야 한다.

변수/함수 스코핑 적용으로서, POLE는 최소한으로 필요한 부분만 노출하기, 가능한 나머지 모든 것을 비공개로 유지하기를 기본으로 하라고 말한다. 전역(또는 외부 함수) 스코프에 모든 것을 놓기 보다 가능한 작고 깊은 중첩 스코프에 변수를 선언하자.

만약 그것에 따라 소프트웨어를 디자인한다면 앞선 3가지 위험 요소를 피할(적어도 최소화할) 더 큰 기회를 가진다.

다음을 보자:

```js
function diff(x,y) {
    if (x > y) {
        let tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}

diff(3,7);      // 4
diff(7,5);      // 2
```

`diff(..)` 함수에서 `y`가 `x`와 같거나 `x` 보다 (얼만큼) 더 큰지 알고싶다. 그래서 뺄셈(`y - x`)을 하면 결과가 `0`이거나 양수다. 만약 초기에 `x`가 `y`보다 더 크면(결과는 음수일 것이다!), 우리는 결과를 양수로 유지하기 위해 `tmp` 변수로 `x`와 `y`를 바꾼다.

:::tip 옮긴이 주
- `x`에 비해 `y`가 얼마나 더 큰지 확인하는 함수 작성(`y - x`을 반환)
- 처음 컨셉은 `x`가 `y`보다 작을 것이라고 가정
- 그러나 그 반대의 경우가 얼마든지 존재하기 때문에 함수를 약간 수정
- `x`가 `y`보다 더 클 경우, 결과를 산출하기 전 두 변수의 값을 교환
- `x` -> `tmp`, `y` -> `x`, `tmp`(`x`) -> `y`와 같이 각각 (재)할당
- 결과는 항상 양수를 유지하고 두 값의 차이를 확인
:::

이 간단한 사례에서, `tmp`가 `if` 블록 안에 있는지 또는 `tmp`가 함수 블록 레벨에 속하는지는 중요하지 않는 것 같아 보인다. `tmp`가 전역 변수가 아니라는 점은 분명하기 때문이다. 하지만 POLE 원칙에 따라 `tmp`는 가능한 스코프 안에 숨어야 한다. 그래서 우리는 `if` 블록에 (**`let`을 사용하여**) `tmp`를 가둔다.

:::tip 옮긴이 주
위 예시 코드에서 `tmp`는 이미 전역 변수가 아니다. 그럼에도 `let`을 사용해 `tmp` 변수를 근접한 블록(`if` 블록) 스코프 내로 제한할 것을 충고하고 있다. 이것이 POLE 원칙을 지키는 습관이다.
:::

## Hiding in Plain (Function) Scope

이제 우리가 변수와 함수 선언을 가능한 저수준(가장 깊이 중첩된) 스코프 안에 숨기는 일이 왜 중요한지 분명해졌을 것이다. 그러면 어떻게 그 일을 할 수 있을까?

이미 `let`과 `const` 키워드는 블록 스코프 선언자임을 알고 있다. 짧지만 더 자세하게 그 키워드를 다룰 것이다. 그러면 우선 `var` 또는 `function` 선언을 스코프에 감춰볼까? 이것은 선언 주위에 `function` 스코프를 감싸는 방법으로 쉽게 해결할 수 있다.

그럼 `function` 스코핑(함수로 래핑하여 변수나 다른 함수의 스코프를 제한하는 것)을 유용하게 사용하는 예시에 대해 생각해보자.

("6!"처럼 쓰는) 수학 연산자 "팩토리얼factorial"은 주어진 정수에 연속적으로 `1`씩 감소하는 모든 더 작은 정수들을 붙인 곱셈이다. 사실 `1`을 곱하는 것은 아무 의미가 없기 때문에 `2`에서 곱셈을 멈출 수 있다. 달리 말하면, "6!"은 "6 *5!"와 같다. 또 이것은 "6* 5 * 4!"와 같고 계속 반복한다. 수반하는 수학의 특성 때문에 ("4!"와 같이) 한번 어떤 주어진 정수의 팩토리얼을 계산했다면 항상 답이 같을 것이므로 다시 그 작업(동일한 정수의 팩토리얼을 계산하는)을 할 필요가 없을 것이다.

그래서 만약 `6` 팩토리얼을 계산했다면 이후 `7` 팩토리얼을 계산하고 싶을 때 2에서 6까지 모든 정수의 팩토리얼을 재계산할 필요가 없을 것이다. 만일 연산 속도를 높이기 위해 메모리를 투자할 의향이 있다면, 계산된 각 정수의 팩토리얼을 캐싱하여 연산력이 낭비되는 문제를 해결할 수 있다.

```js
var cache = {};

function factorial(x) {
    if (x < 2) return 1;
    if (!(x in cache)) {
        cache[x] = x * factorial(x - 1);
    }
    return cache[x];
}

factorial(6);
// 720

cache;
// {
//     "2": 2,
//     "3": 6,
//     "4": 24,
//     "5": 120,
//     "6": 720
// }

factorial(7);
// 5040
```

다수의 `factorial(..)` 호출에 걸쳐서, 이전 연산 결과가 남아있도록 계산한 모든 팩토리얼을 `cache`에 저장하고 있다. 그러나 `cache` 변수는 외부 스코프에 노출되는 것이 아닌(특히, 전역 스코프가 아닌), `factorial(..)`이 작동하는 방법에 대한 *비공개* 세부 정보가 명백하다.

:::tip NOTE
`factorial(..)`은 재귀적(자신에 대한 호출이 내부에서 이루어진다)이지만 단지 코드의 간결함만을 위한 것이다. 비재귀적 수행은 `cache` 관점에서 같은 스코핑 분석 결과를 산출할 것이다.
:::

하지만, 이 과다 노출 이슈를 해결하는 것은 보이는 것처럼 `factorial(..)` 함수 안에 `cache` 변수를 숨기는 것과 같이 간단하지 않다. 다중 호출 시 재할당을 위해 필요하므로 `cache` 변수는 해당 함수 바깥쪽 스코프에 위치해야 한다. 그렇다면 우리는 어떻게 할 수 있을까?

`cache`가 위치하기 위한 (`factorial(..)` 내부 스코프와 외부/전역 스코프 사이에) 다른 중간 스코프를 정의하자.

```js
// outer/global scope

function hideTheCache() {
    // "middle scope", where we hide `cache`
    var cache = {};

    return factorial;

    // **********************

    function factorial(x) {
        // inner scope
        if (x < 2) return 1;
        if (!(x in cache)) {
            cache[x] = x * factorial(x - 1);
        }
        return cache[x];
    }
}

var factorial = hideTheCache();

factorial(6);
// 720

factorial(7);
// 5040
```

`hideTheCache()` 함수는 `factorial(..)`의 다중 호출을 지속하기 위해 `cache`를 위한 스코프 생성 이외 다른 목적으로 제공하지 않는다. 그러나 `cache`에 액세스하고 있는 `factorial(..)` 때문에, 우리는 해당하는 동일 스코프 안에서 `factorial(..)`을 정의해야 한다. 그런 뒤 `hideTheCache()` 내부에서 그 함수의 참조를 리턴하고 외부 스코프에서 `factorial`으로 명명된 변수에 그 참조를 저장한다. 이제 `factorial(..)`을 여러 번 호출할 때, `cache`는 숨겨진 채로 `factorial(..)`에만 접속할 수 있도록 계속 유지된다!

그런데 변수/함수를 숨겨야 할 필요가 있을 때마다 `hideTheCache(..)` 함수 스코프를 명명하고 정의하는 일은 짜증 날 것이다. 특히, 이 함수와 이름 충돌을 피하고 싶을 것이다.

:::tip NOTE
앞서 묘사한 테크닉(예상되는 동일 입력의 호출을 반복할 때 퍼포먼스를 최적화하기 위해 함수의 계산된 결과를 캐싱하는 것)은 원론적으로 "메모이제이션memoization"에 관련된 함수형 프로그램Functional Programming (FP) 세계에서는 아주 흔하다. 이 캐싱은 클로저closure에 의존한다(챕터 7 참조). 또한, (부록 B의 "A Word About Memory"에서 설명하는) 메모리 사용의 주의점이다. FP 라이브러리는 보통 함수의 메모이제이션(여기서는 `hideTheCache(..)`를 대신할 수 있다)을 위해 최적화되고 점검된 기능을 제공할 것이다. 메모이제이션은 우리의 논의 범위를 벗어나지만, 더 많은 정보가 필요하면 *[Functional-Light JavaScript](<https://github.com/getify/Functional-Light-JS>)* 책(저자의 다른 도서)을 보자.
:::

오직 변수를 숨길 목적의 스코프를 만들어야 하는 상황이 발생할 때마다 고유하고 새로운 이름의 함수를 정의하기 보다, 아마 더 나은 해결 방법은 함수 표현식을 사용하는 것이다.

```js
var factorial = (function hideTheCache() {
    var cache = {};

    function factorial(x) {
        if (x < 2) return 1;
        if (!(x in cache)) {
            cache[x] = x * factorial(x - 1);
        }
        return cache[x];
    }

    return factorial;
})();

factorial(6);
// 720

factorial(7);
// 5040
```

잠깐! 상기 예시는 `cache`를 숨길 목적으로 스코프를 생성하기 위해 여전히 함수를 사용하고 있다. 그리고 그 함수는 여전히 `hideTheCache`로 명명돼 있다. 그래서 이 예시가 어떻게 문제를 해결했다는 것인가?

챕터 3의 "Function Name Scope"를 상기하면,`function` 표현식의 이름 식별자에 무슨 일이 일어났는가? `hideTheCache(..)`는 `function` 선언식 대신 `function` 표현식으로 정의됐기 때문에, 해당 이름은 외부/전역 스코프가 아니라 함수 자신이 소유한 스코프(본질적으로 `cache`와 동일한 스코프) 안에 있다.

그것은 우리가 함수 표현식(과 같은 단일 작업occurence)에 정확히 동일한 이름을 명명할 수 있고, 어떠한 이름 충돌도 없다는 것을 의미한다. 더 적절하게 표현하면, 우리는 숨기려 하는 것(예시의 경우 `cache`)에 기반하여 의미론적으로 각각의 작업(함수 표현식)에 이름을 지을 수 있다. 그리고 우리가 선택한 어떤 이름도 프로그램 안에서 다른 `function` 표현식 스코프와 충돌이 일어날 걱정을 하지 않을 수 있다.

사실, 우리는 "익명 `function` 표현식"으로 대체하면 완전히 이름을 제거*할 수도 있*다. 그러나 부록 A는 이와 같은 스코프 전용scope-only 함수를 위해 이름의 중요성에 대해 논할 것이다.

### Invoking Function Expressions Immediately

앞서 본 팩토리얼 재귀 프로그램에서 놓치기 쉽지만 중요한 또 다른 부분은 `})():`을 포함하는 `function` 표현식의 끝 라인이다.

`(..)`으로 전체 `function` 표현식을 감싸고, 끝에 두 번째 `()` 괄호쌍을 추가한 것을 주목하자. 이것은 실제로 우리가 정의한 `function` 표현식을 호출한다. 더불어, 이 경우 함수 표현식을 둘러싸는 `(..)`의 첫 번째 쌍은 반드시 필요하지 않지만 가독성을 위해 사용했다.

다시 말해, 우리가 `function` 표현식을 정의하면 그때 즉시 호출된다. 이 흔한 패턴은 (매우 창의적인) 이름을 갖고 있다. 즉, 즉시 실행 함수 표현식(Immediately Invoked Function Expression, IIFE)이다.

IIFE는 변수/함수를 숨기기 위해 함수를 생성하고 싶을 때 유용하다. 이것은 표현식이기 때문에, 표현식이 허용되는 JS 프로그램의 **어떤** 장소에서도 사용될 수 있다. IIFE은 `hideTheCache()`처럼 이름을 붙이거나 (더욱 더 흔하게) 이름 없이/익명으로 사용될 수 있다. 그리고 이것은 단독 실행되거나 앞선 예시와 같이 다른 문의 일부일 수 있다. 예를 들어, `hideTheCache()`은 `factorial()` 함수의 참조를 반환하고 그것은 변수 `factorial`에 `=`으로 할당된다.

비교를 위해, 단독 실행 IIFE의 예시가 있다.

```js
// outer scope

(function(){
    // inner hidden scope
})();

// more outer scope
```

앞서의 `hideTheCache()`는 외부를 감싸는 `(..)`의 사용 여부를 선택할 수 있지만, 단독 실행형 IIFE은 `(..)`가 반드시 **필요하다**. 따라서, 이것들은 문이 아닌 표현식으로 `function`를 구분한다. 하지만 일관성을 위해 항상 IIFE `function` 주위를 `(..)`로 감싼다.

:::tip NOTE
기술적으로, 둘러싸는 `(..)`는 함수 표현식으로서 JS 파서에 의해 처리되는 IIFE 안의 `function`를 확인하기 위한 구문론적인 방법만이 아니다. 우리는 부록 A에서 조금 다른 옵션들을 볼 것이다.
:::

#### Function Boundaries

스코프를 정의하기 위해 IIFE를 사용하면 IIFE 주위 코드에 따라 어떤 의도하지 않은 결과가 발생할 수 있다는 점을 주의하자. IIFE는 완전한 함수이기 때문에 그 함수의 경계는 특정 문/구조의 동작 바꾼다.

예를 들어, IIFE가 코드 주위를 감싼다면 해당 코드에 있는 `return` 문은 의미가 바뀔 것이다. `return`은 IIFE 함수를 참조할 것이기 때문이다. 또한, 화살표 함수가 아닌 IIFE는 `this` 키워드의 바인딩을 바꾼다(Objects & Classes 책에 더 많은 정보가 있다). `break`와 `continue`와 같은 구문은 외부 루프나 블록을 통제하기 위해 IIFE 함수 경계를 가로질러 작동하지 않을 것이다.

그래서, 만약 스코프를 애워쌀 필요가 있는 코드가 그 안에 `return`, `this`, `break`, 또는 `continue`를 가졌다면, IIFE는 아마 최선의 접근법이 아닐 가능성이 있다. 해당 사례에서, 함수 대신 블록으로 스코프를 생성하는 것을 볼 수 있다.

## Scoping with Blocks

이쯤이면, 당신은 식별자 노출을 제한하는 스코프 생성의 장점에 대해 꽤 편하게 느낄 것이다.

여태까지, 우리는 `function`(i.e., IIFE) 스코프를 통해, 이것이 작동하는 것을 보았다. 그러면 이제 중첩 블록에서 `let` 선언의 사용을 고려해 보자. 일반적으로, 어떤 `{ .. }` 중괄호쌍curly-brace pair 문은 블록처럼 동작할 것이다. 그러나 스코프로서 **필수적이지 않다**.

블록은 필요할 때(즉, 해당하는 블록-스코프 선언을 포함될 때(i.e. `let` 또는 `const`))만 스코프가 된다. 다음을 참조하자.

```js
{
    // not necessarily a scope (yet)

    // ..

    // now we know the block needs to be a scope
    let thisIsNowAScope = true;

    for (let i = 0; i < 5; i++) {
        // this is also a scope, activated each
        // iteration
        if (i % 2 == 0) {
            // this is just a block, not a scope
            console.log(i);
        }
    }
}
// 0 2 4
```

모든 `{ .. }` 중괄호쌍이 블록을 생성하지 않는다 (따라서 그들이 스코프가 될 의무가 없다)

- 객체 리터럴은 그들의 key-value 리스트의 범위를 한정하기 위해 `{ .. }` 중괄호쌍을 사용한다. 그러나 그러한 객체의 값은 스코프가 **아니다**.

- `class`는 자신의 바디 정의 주위에 `{ .. }` 중괄호를 사용한다. 그러나 이것은 블록 또는 스코프가 아니다.

- `function`은 자신의 바디 주위에 `{ .. }`를 사용한다. 그러나 이것은 기술적으로 블록이 아니다(즉, 함수 바디를 위한 단문이다). 하지만, 스코프다.

- `switch` 문, 구체적으로 `case` 구문의 세트 주위를 감싸는 `{ .. }` 중괄호는 블록/스코프를 정의하지 않는다.

이와 같이 블록이-아닌 예시들 이외, `{ .. }` 중괄호쌍은 (`if` 또는 `for`와 같은) 문을 덧붙여 블록을 정의하거나 직접 단독 실행할 수 있다. 이전 스니펫에서 가장 바깥의 `{ .. }` 중괄호를 참고하자. 이 종류의 명시적 블록은 의미론적 신호로서는 유용할지 몰라도 동작의 목적으로 제공되지 않는다(블록 안에 선언이 없으면 실제로 스코프가 아니다).

명시적 단독 실행형 `{ .. }` 블록은 항상 JS 구문에 유효하지만, ES6의 `let`/`const` 이전에는 스코프가 될 수 없기 때문에, 그들은 아주 보기 드물다. 하지만, ES6 이후부터 조금씩 나타나기 시작하고 있다.

블록 스코프를 지원하는 대부분의 언어에서, 명시적 블록 스코프는 하나 또는 몇 개의 변수들을 위해 스코프의 좁은 단면을 생성하는 매우 흔한 패턴이다. 그래서 POLE 원칙에 따라, 마찬가지로 JS에서도 해당 패턴을 더욱 폭넓게 받아들여야 할 것이다. 실제적으로 최소한 식별자 노출을 좁히기 위해 (명시적) 블록 스코핑을 사용하자.

명시적 블록 스코프는 (외부 블록이 스코프든 아니든) 또 다른 블록 안에서도 유용할 수 있다.

예를 들어,

```js
if (somethingHappened) {
    // this is a block, but not a scope

    {
        // this is both a block and an
        // explicit scope
        let msg = somethingHappened.message();
        notifyOthers(msg);
    }

    // ..

    recoverFromSomething();
}
```

여기서, `if` 문 **안** `{ .. }` 중괄호쌍은 `msg`를 위해 심지어 더 작고, 명시적인 내부 블록 스코프가 있다. 해당 변수(`msg`)는 전체 `if` 블록에 사용되지 않기 때문이다. 대부분의 개발자들은 그냥 `msg`의 블록 스코프를 `if` 블록으로 하고 계속 진행할 것이다. 그리고 공정하게 말하면, 고려해야할 코드가 몇 줄 뿐이라면 그것은 동전던지기 판정이다. 그러나 코드가 많아졌을 때, 이 과다 노출 이슈는 더욱 잦아진다.

그러면 이것은 여분의 `{ .. }` 중괄호쌍과 들여쓰기 레벨를 추가할만큼 충분히 고려할 문제일까? 내 생각에 당신은 POLE 원칙에 따라 항상 (합리적으로) 각 변수마다 가장 작은 블록을 정의해야 한다. 그래서 앞서 본 것처럼 여분의 명시적 블록 스코프를 사용하길 권장한다.

(챕터 5) "Uninitialized Variables (TDZ)"의 TDZ 오류에 대한 논의를 상기해 보자. 나의 제안이 거기에 있다. `let`/`const` 선언을 항상 스코프 상단으로 놓아 TDZ 오류의 위험성을 최소화하는 것이다.

만약, 스코프 중간에서 `let` 선언을 놓아야 한다면, 우선 "안돼! TDZ 경고!임을 인식하고, 만약 앞의 `let` 선언이 해당 블록의 위쪽 절반에서 요구되지 않는다면, 그 변수의 노출을 줄이기 위해 명시적 중첩 블록 스코프를 사용해야 한다!

명시적 블록 스코프를 동반한 다른 예시:

```js
function getNextMonthStart(dateStr) {
    var nextMonth, year;

    {
        let curMonth;
        [ , year, curMonth ] = dateStr.match(
                /(\d{4})-(\d{2})-\d{2}/
            ) || [];
        nextMonth = (Number(curMonth) % 12) + 1;
    }

    if (nextMonth == 1) {
        year++;
    }

    return `${ year }-${
            String(nextMonth).padStart(2,"0")
        }-01`;
}
getNextMonthStart("2019-12-25");   // 2020-01-01
```

우선 스코프와 스코프의 식별자들을 찾아 보자.
1. 외부/전역 스코프는 1개의 식별자, `getNextMonthStart(..)` 함수가 있다.
2. `getNextMonthStart(..)` 함수 스코프는 3개의 식별자가 있다(`dataStr`(parameter), `nextMonth`, 그리고 `year`).
3. `{ .. }` 중괄호쌍은 `curMonth` 변수 1개를 포함하는 내부 블록 스코프를 정의한다.

근데 왜 `curMonth`를 (함수 스코프의 상위에 있는 `nextMonth`와 `year`를 옆에 놓는 대신) 명시적 블록 스코프에 놓았을까? 그 이유는 `curMonth`는 그 다음에 오는 두 개의 문에만 요구되기 때문이다. 반면, 함수 스코프 레벨에서는 과노출된다.

이 예시는 작다. 그래서 `curMonth` 과노출의 위험성은 매우 제한된다. 그러나 POLE 원칙의 혜택은, 습관처럼 스코프 노출을 최소화해야 한다는 의식 구조에 적응할 때 가장 크게 성취된다. 만약 작은 경우일지라도 일관성 있게 원칙을 따른다면, 프로그램이 커질 수록 더욱 큰 혜택을 제공할 것이다.

이제 훨씬 더 실체가 있는 예시를 살펴보도록 하자.

```js
function sortNamesByLength(names) {
    var buckets = [];

    for (let firstName of names) {
        if (buckets[firstName.length] == null) {
            buckets[firstName.length] = [];
        }
        buckets[firstName.length].push(firstName);
    }

    // a block to narrow the scope
    {
        let sortedNames = [];

        for (let bucket of buckets) {
            if (bucket) {
                // sort each bucket alphanumerically
                bucket.sort();

                // append the sorted names to our
                // running list
                sortedNames = [
                    ...sortedNames,
                    ...bucket
                ];
            }
        }

        return sortedNames;
    }
}

sortNamesByLength([
    "Sally",
    "Suzy",
    "Frank",
    "John",
    "Jennifer",
    "Scott"
]);
// [ "John", "Suzy", "Frank", "Sally",
//   "Scott", "Jennifer" ]
```

5개의 다른 스코프들에 걸쳐 선언된 6개의 식별자들이 있다. 이 모든 변수들은 단일한 외부/전역 변수에 존재할 수 있을까? 기술적으로 그것들은 모두 고유하게 명명됐고 따라서 이름이 충돌하지 않기 때문에 맞는 말이다. 그러나 이것은 매우 바보같은 코드 구조이고, 혼동과 향후 발생할지 모를 버그들을 유발하기 쉽다.

우리는 그 변수들을 적절한 각각의 내부 중첩 스코프로 분리한다. 각 변수는 필요에 따라 작동하는 프로그램을 위해 가능한 가장 깊은 스코프에 정의된다.

`sortedNames` 변수는 최상위 함수 스코프에 정의됐을 수도 있으나, 오직 이 함수의 두 번째 절반에서만 사용되어진다. 최상위 스코프 변수의 과노출을 피하기 위해, 우리는 다시 POLE 원칙을 따라서 해당 변수를 내부의 명시적 블록 스코프 안으로 스코프를 제한한다.

### `Var` and `let`

`var buckets` 선언에 대해 이야기해 보자. 이 변수는 (마지막 `return` 문을 제외하고) 함수의 모든 곳에서 사용된다. 함수의 모든(또는 대부분) 영역에서 필요한 어떤 변수라도 그러한 사용이 명백하도록 선언돼야 한다.

:::tip NOTE
매개변수 `names`은 함수의 모든 곳에서 사용되지 않지만, 매개변수의 스코프를 제한하는 방법이 없다. 그래서 매개변수는 함수 범위 선언처럼 작동한다.
:::

그럼 `buckets` 변수 선언 시 왜 `let` 대신 `var`를 사용했을까? 여기서 `var`를 선택한 것은 의미론적이고 기술적인 두 이유 모두 있다.

스타일적으로, `var`는 초창기 JS 때부터 "변수는 함수의 모든 영역에 속한다"라는 의미가 있었다. 1장의 "Lexical Scope" 파트에서 주장한 것처럼, `var`는 자신을 둘러싸는 것 중 가장 근접한 함수의 스코프로 첨부되고(옮주:해당 스코프의 멤버가 되고), 그것이 나타나는 위치는 중요하지 않다. 그것은 `var`가 블록 안에 있을지라도 마찬가지다.

```js
function diff(x,y) {
    if (x > y) {
        var tmp = x;    // `tmp` is function-scoped
        x = y;
        y = tmp;
    }

    return y - x;
}
```

`var`가 블록 안에 있더라도, 해당 선언은 블록 스코프가 아닌 (`diff(..)`으로) 함수 스코프를 갖는다.

`var`를 블록 안에 선언할 수 있더라도(그리고 그것은 여전히 함수 스코프이다), 나는 몇몇 특정 사례(부록 A에서 논의)를 제외하고 이러한 접근법을 권장하지 않는다. 달리 말해, `var`는 함수에서 최상위 스코프에 예약되어야 한다.

해당하는 동일 스코프(함수 안 최상위 스코프)에 `let`을 사용할 순 없을까? `var`는 시각적으로 `let`과 구별되고 따라서 명확히 말해 "이 변수는 함수 스코프를 갖고 있다"라고 암시하기 때문에, 함수 안 최상위 스코프에 `let`을 사용하는 것은 (특히 함수의 앞쪽 라인이 아니며, 블록 안 다른 모든 선언이 `let`을 사용할 경우) 함수 스코프 선언과의 차이를 보여주는데 시각적으로 매력적이지 않다.

다른 말로, 나는 `var`가 함수 스코프임을 더 잘 표현하고, `let`은 블록 스코프임을 더 잘 전달한다고 느낀다. 당신의 프로그램이 함수 스코프 변수와 블록 스코프 변수를 둘 다 필요로하는 한, 가장 감각적이고 가독성 있는 접근법은 `var`와 `let` 모두를 그들이 가진 최상의 목적에 맞게 사용하는 것이다.

다른 사례로서 `var` 또는 `let` 선택에 대한 의미론적semantic이고 운영론적operational인 다른 이유들이 있다. 우리는 부록 A에서 `var`와 `let`의 사례를 더 자세히 살펴볼 것이다.

:::warning
`var`와 `let` 둘 모두를 사용한다는 나의 권고는 명백히 논란이 많고 다수의 의견과 배치된다. 더 흔하게는 다음과 같은 주장을 들을 수 있다. "var는 고장났고, let은 그것을 고친다.", "절대 var를 사용하지 말고 let으로 대체하라." 이 의견들은 타당하지만 단지 나와 같은 의견들이다. `var`는 사실상 고장나거나 폐기되지 않았다. 이것은 초기 JS 이래로 작동해 왔고 JS가 존재하는 한 계속 작동할 것이다.
:::

### Where To `Let`?

반드시(대부분) 함수 스코프의 최상위에 `var`를 놓으라는 나의 조언은 다른 대부분의 선언들을 `let`으로 사용해야 한다는 의미다. 그러나 프로그램의 각 선언이 속할 위치를 결정하는 방법에 대해 여전히 궁금할 것이다.

POLE는 그것을 결정하는데 이미 도움을 준다. 다만, 우리는 그것을 명확히 말할 수 있는지 확인해 봐야 한다. 결정하는 데 필요한 방법은 당신이 사용할 키워드에 근거하지 않는다. 결정하는 데 필요한 방법은 다음과 같은 질문이다. "이 변수에 충분한, 최소 스코프 노출은 무엇일까?"

일단 그 질문에 답할 수 있다면, 당신은 변수가 블록 스코프 또는 함수 스코프에 속하는지 알 것이다. 만약, 당신이 초기에 변수는 블록 스코프에 속해야 한다고 정한다면, 그리고 나중에 그 변수를 함수 스코프로 올려야 할 필요를 깨닫는다면, 그때 이것은 해당하는 변수 선언의 위치 뿐만 아니라 사용된 선언자 키워드의 변화에 영향을 미친다. 결정하는 과정은 실제로 그처럼 진행해야 한다.

만약 선언이 블록 스코프에 속한다면 `let`을 사용한다. 만약 함수 스코프에 속한다면 `var`를 사용한다(다시 말하지만, 단지 나의 의견이다).

그러나 이 결정하는 일을 어느 정도 시각화하기 위한 또 다른 방법은 프로그램의 예비 ES6 버전을 참고하는 것이다. 예를 들어, 앞서 본 `diff(..)`를 상기하면,

```js
function diff(x,y) {
    var tmp;

    if (x > y) {
        tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}
```

`diff(..)`의 이번 버전에서, `tmp`는 명확히 함수 스코프로 선언된다. 이것은 `tmp`에 적절할까? 나는 '아니오'라고 말할 것이다. `tmp`는 단지 몇몇 문을 위해서만 사용되고, `return` 문에는 필요하지 않다. 따라서 블록 스코프로 선언되어야 한다.

ES6 이전에, `let`이 없었기 때문에 *실질적으로* 변수를 블록 스코프로 선언할 수 없었다. 그러나 우리는 우리의 의도를 암시하는 차선의 방법을 실행할 수 있다.

```js
function diff(x,y) {
    if (x > y) {
        // `tmp` is still function-scoped, but
        // the placement here semantically
        // signals block-scoping
        var tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}
```

`if` 문 안에 `tmp`를 위한 `var` 선언을 놓는 것은 `tmp`가 그 블록에 속한다는 것을 코드 리더에게 암시한다. JS가 스코프 제한을 강제하지 않을지라도 의미론적 신호는 당신의 코드를 읽는 리더를 위해 여전히 유익하다.

이러한 관점에 따라, 당신은 이러한 종류의 블록 안에서 다른 `var`를 찾을 수 있고, 그리고 이미 전해지고 있는 의미론적 암시를 강화하기 위해 선언자를 `let`으로 바꿀 수 있다. 내 의견으로는, 이것이 `let`의 적절한 사용법이다.

역사적으로 `var`에 기반했지만 이제는 꽤 오랫동안 항상 `let`을 사용하는, 다른 예시는 `for` 루프다.

```js
for (var i = 0; i < 5; i++) {
    // do something
}
```

그와 같은 루프가 정의되는 위치는 중요하지 않다. `i`는 기본적으로 항상 루프 안에서만 사용될 것이다. 이와 같은 예시에서 POLE는 `var` 대신 `let`으로 선언되어야 함에 영향을 미친다.

```js
for (let i = 0; i < 5; i++) {
    // do something
}
```

위와 같이 `var`를 `let`으로 변경했을 때 당신의 코드가 "중단"될 수 있는 거의 유일한 경우는 아래 예시와 같이 루프 외부/뒤에서 루프 반복자(`i`)에 엑세스할 때다.

:::tip
- 보통, 루프에서 `var`를 `let`으로 변경해도 아무런 문제가 발생하지 않는다.
- 그러나 거의 드물게(유일하게) 오류가 발생(코드 실행이 중단)하는 경우가 있는데,
- 아래 예시와 같이, 루프 외부에서 반복자 `i`에 접근하는 시도가 있을 경우다. (`ReferenceError: i is not defined`)
- 따라서, 아래 예시는 `let` 대신 `var`를 사용하고 있지만, 이것은 바보같은 코드다.
- 권장되는 방법은 `i`의 값을 루프 외부로 넘겨주는 새 변수를 추가하는 것이다. 새 변수는 외부에 선언한다. (아래 아래 예시 참고)
:::

```js
for (var i = 0; i < 5; i++) {
    if (checkValue(i)) {
        break;
    }
}

if (i < 5) {
    console.log("The loop stopped early!");
}
```

이 사용 패턴은 끔찍하게도 드물지 않지만, 대부분은 바보같은 코드 구조라고 느낀다. 선호하는 접근법은 해당 목적으로 또 다른 외부 스코프 변수를 사용하는 것이다.

```js
var lastI;

for (let i = 0; i < 5; i++) {
    lastI = i;
    if (checkValue(i)) {
        break;
    }
}

if (lastI < 5) {
    console.log("The loop stopped early!");
}
```

`lastI`는 이 스코프 전체에 걸처 사용된다. 그래서 `var`로 선언되었다. `i`는 오직 각 루프 반복 안에서 사용되고, `let`으로 선언된다.

### What's the Catch?

지금까지 우리는 `var`와 매개변수는 함수 스코프를 갖고, `let`/`const`는 블록 스코프 선언을 암시한다고 말했다. 여기 초대할 하나의 작은 예외(`catch` 절)가 있다.

`try..catch`의 도입이 ES3(1999년)에서 지지받은 이후, `catch` 절은 추가적으로 (조금 알려진) 블록 스코프 선언의 기능이 사용되었다.

```js
try {
    doesntExist();
}
catch (err) { // Is this parameter function-scoped? NO.
    console.log(err);
    // ReferenceError: 'doesntExist' is not defined
    // ^^^^ message printed from the caught exception

    let onlyHere = true;
    var outerVariable = true;
}

console.log(outerVariable);     // true

console.log(err);
// ReferenceError: 'err' is not defined
// ^^^^ this is another thrown (uncaught) exception
```

`catch` 절에서 선언된 `err` 변수는 해당하는 블록으로 제한되는 블록 스코프이다. 이 `catch` 절 블록은 `let`으로 다른 블록 스코프 선언들을 소유할 수 있다. 그러나 블록 안의 `var` 선언은 외부 함수 스코프/전역 스코프에 속한다.

ES2019는 (최근 작성 당시) `catch` 절의 선언(매개변수)을 선택사항으로 변경했다. 선언이 생략됐다면 (기본 설정에 따라) `catch` 블록은 더 이상 스코프가 아니다. 그렇지만 그것은 여전히 블록이다.

:::tip 옮긴이 주
- "선언이 생략됐다면 (기본 설정에 따라) `catch` 블록은 더 이상 스코프가 아니다. 그렇지만 그것은 여전히 블록이다."
- 여기서 "스코프가 아니다"라는 말은 매개변수을 위해 블록 바깥에 형성된 스코프(이를테면, 5장에서 언급한 루프 반복자 선언의 재할당을 가능하도록 하기 위해 블록을 감싸고 있는 별도로 만들어진 스코프 - 비록 이해를 돕기 위한 묘사라고 했지만)가 사라진다는 것을 의미하는 것일까? 반면 `catch` 블록은 블록 스코프로서 제 기능을 유지한다 = 변하는 게 없다.
- 다시 정리하면, 매개변수 선언이 생략되면 그와 함께 만들어진 스코프도 사라진다!? 반면, 블록은 그대로 기능을 유지한다.
:::

만약 *예외가 발생하는* (그럼에도 우아하게 복구할 수 있는) 상황에 대응할 필요가 있다면, 그러나 오류 값 자체를 신경쓰지 않는다면, `catch` 선언(매개변수)을 생략할 수 있다.

:::tip 옮긴이 주
혼동을 피하기 위해 남겨둔다. `catch` 선언(declaration)이라 하면 무심코 `catch` 절(즉, `catch` + (err) + { .. }을 조합한 상태)로 받아들일 수 있는데, 정확히는 `catch` 절에 선언된 매개변수(`(err)`)를 뜻한다.
:::

```js
try {
    doOptionOne();
}
catch {   // catch-declaration omitted
    doOptionTwoInstead();
}
```

이 구문은 꽤 흔한 용례로서 작지만 기분좋은 단순함이 있다. 또한 불필요한 스코프를 제거하는데 약간 더 효과적일 수 있다.

## Function Declarations in Blocks (FiB)

우리는 블록 스코프인 `let` 또는 `const`를 사용한 선언들과 함수 스코프인 `var` 선언들을 보았다. 그럼 블록 내에서 직접 노출된 `function` 선언은 어떨까? 특별히, 이것은 "FiB"라고 부른다.

우리는 일반적으로 `function` 선언을 `var` 선언과 동등한 것처럼 생각한다. 그럼 그것은 `var`처럼 함수 스코프에 해당할까?

맞기도 하고 틀리기도 하다. 혼란스러울 것이다. 이제부터 그 이면을 들여다 보자.

```js
if (false) {
    function ask() {
        console.log("Does this run?");
    }
}
ask();
```

이 프로그램의 실행 결과를 어떻게 예측하는가? 3가지 합리적으로 추론할 수 있는 결과는 다음과 같다.

1. `ask()` 호출은 `ReferenceError` 예외와 함께 실패할 것이다. 왜냐하면 `ask` 식별자는 `if` 블록 스코프 안에서 블록 스코프로 존재하고 따라서 외부/전역 스코프에서 사용할 수 없다.
2. `ask()` 호출은 `TypeError` 예외와 함께 실패할 것이다. 왜냐하면 `ask` 식별자는 존재하지만 (`if`문이 실행하지 않았기 때문에) `undefined` 상태이며, 따라서 호출할 수 있는 함수가 아니다.
3. `ask()` 호출은 정상적으로 실행되고, "Does it run?" 메시지가 출력될 것이다.

혼동스러운 파트: 해당 코드 스니펫을 실행하는 JS 환경에 따라, 다른 결과를 얻을 수 있다. 이것은 소수의 크레이지 영역들 중 하나이고, 존재하는 레거시 동작은 예상할 수 있는 결과를 저버린다.

**JS 명세서는 블록 안에서 선언된 `function`는 블록 스코프라고 말한다.** 따라서 그에 대한 답은 (1)이 되어야 한다. 하지만, 대부분 JS 엔진 기반 브라우저(크롬에서 유래했지만 또한 Node에서도 사용되는 V8 포함하여)는 (2)처럼 작동할 것이다. 식별자가 `if` 블록 바깥의 스코프에 속하지만, 함수 값은 자동으로 초기화되지 않기 때문에 `undefined`로 유지됨을 의미한다.

**어째서 브라우저의 JS 엔진은 명세서에 반대되는 동작을 허용할까?** 그 이유는 이 엔진은 ES6 블록 스코프를 도입하기 전 FiB와 관련한 특정 작동법이 있었고, 명세서에 따라 변경하면 이미 존재하는 웹사이트의 JS 코드를 망가트릴 수 있다는 점을 고려했기 때문이다.

:::tip NOTE
Node는 대개 서버로 작동하기 때문에, 일반적으로 브라우저의 JS 환경으로 분류하지 않는다. 그러나 Node의 v8 엔진은 크롬 (그리고 에지) 브라우저와 공유된다. v8이 첫번 째 브라우저 JS 엔진이 때문에, 이것은 부록 B 예외에서 논의한다, 브라우저 예외 사항은 Node로 확장됨을 의미한다.
:::

블록 안에 `function` 선언을 위치시키는 가장 흔한 용례 중 하나는 어떤 환경 상태에 따라 조건부적으로 단일하게 또는 (`if..else` 문의 동반과 같이) 다른 방법으로 함수를 정의하는 것이다. 예를 들어,

```js
// 조건에 따라 `isArray`를 다르게 선언한다.
// 처음 함수를 선언할 때, 즉 1회만 `typeof Array.inArray`를 체크한다.
if (typeof Array.isArray != "undefined") {
    function isArray(a) {
        return Array.isArray(a);
    }
}
else {
    function isArray(a) {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    }
}
```

```js
// (원문에서는 더 아래쪽에 나오는 코드)
// 상기 코드를 아래와 같이 정의할 수도 있다.
// 하지만, `isArray` 함수를 실행할 때마다,
// `typeof Array.isArray` 체크를 하면서 연산력을 낭비한다.
function isArray(a) {
    if (typeof Array.isArray != "undefined") {
        return Array.isArray(a);
    } else {
        return Object.prototype.toString.call(a) == "[object Array]";
    }
}
```

`typeof Array.isArray` 체크가 단 한 번만 수행되기 때문에, 성능을 이유로 이런 방법으로 코드를 구성하고 있다. 이것은 단 하나의 `isArray(..)`를 정의하고 그 안에 `if` 문을 넣는 것과 상반된다. 즉, 해당 함수를 체크하는 작업은 호출할 때마다 불필요하게 실행될 것이다.

:::warning
FiB 일탈의 위험성에 더하여, 함수 안 조건문 정의의 또 다른 문제는 그와 같은 프로그램은 디버깅이 더 어렵다는 것이다. 만약 `isArray(..)` 함수 안의 버그를 처리하려면, 우선 `isArray(..)` 수행이 실제로 실행되는 것을 이해해야 한다. 때때로, 그 버그는 조건문 체크가 부정확하기 때문에 발생한 오류의 하나다! 만약 함수의 멀티 버전을 정의한다면, 해당 프로그램은 버그를 추론하고 유지관리가 항상 어렵다.
:::

이전 스니펫에 더해서, 몇몇 다른 FiB 예외 사례(corner cases)가 숨어 있다. 다양한 브라우저들과 비브라우저 JS 환경(브라우저 기반이 아닌 JS 엔진)에서 다음과 같은 동작들은 다를 것이다. 예를 들어,

```js
if (true) {
    function ask() {
        console.log("Am I called?");
    }
}

if (true) {
    function ask() {
        console.log("Or what about me?");
    }
}

for (let i = 0; i < 5; i++) {
    function ask() {
        console.log("Or is it one of these?");
    }
}

ask();

function ask() {
    console.log("Wait, maybe, it's this one?");
}
```

챕터 5의 "When Can I Use a Vriable?"에 서술된 함수 호이스팅이 다음을 제시했다는 점을 상기하자. 위 스니펫의 마지막 `ask()` 함수는 `ask()`를 호출하는 구문 위로 호이스트할 것이다. `ask()` 함수는 해당하는 이름의 마지막 함수 선언이기 때문에, "승리"해야 할 것이다(은유적 표현). 맞지? 불행히도 아니다.

위와 같은 모든 이상한 예외 사례(corner cases)를 문서화할 의도가 아닐 뿐만 아니라, 각각의 사례들이 특별한 방식으로 작동하는 이유를 설명하려는 것도 아니다. 내 생각에, 이 정보는 불가사의한 레거시 상식이다.

FiB에 대한 나의 진짜 관심은, 모든 환경에서 당신의 코드가 예측할 수 있는 작동을 보증하기 위해 나는 어떤 조언을 할 수 있는가?, 에 있다.

나로서는, FiB의 예측할 수 없는 변화를 피하기 위한 실제적으로 유일한 대답은 간단히 말해 전체적으로 FiB를 회피하라는 것이다. 다시 말하면, 절대로 `function` 선언을 어떤 블록 안에도 직접 놓지 말고, 반드시 함수(또는 전역 스코프)의 최상위 스코프 안에 두도록 하라는 것이다.

앞쪽 `if..else` 예제에 관하여, 나의 제안은 이왕에 가능하다면 조건문 안에 함수 정의하기를 피하라는 것이다. 그렇다. 이것은 성능이 조금은 떨어질 수 있지만 전체적 관점에서 더 낫다.

:::tip 옮긴이 주
저자는 `if..else` 예제에서는 함수를 실행할 때마다 불필요하게 `typeof` 체크를 하므로 연산력이 낭비된다고 말했다. 그럼에도 디버깅 등 전체적인 관점에서 아래 코드가 더 낫다고 주장한다.
:::

```js
function isArray(a) {
    if (typeof Array.isArray != "undefined") {
        return Array.isArray(a);
    }
    else {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    }
}
```

만약 해당 코드의 수행이 당신의 애플리케이션에 치명적인 패스 이슈(path issue)를 불러온다면, 다음과 같은 접근법을 고려해 보길 바란다.

```js
// 함수 표현식의 재할당을 이용하는 방법
// 불필요한 연산이 사라졌다
var isArray = function isArray(a) {
    return Array.isArray(a);
};

// override the definition, if you must
if (typeof Array.isArray == "undefined") {
    isArray = function isArray(a) {
        return Object.prototype.toString.call(a)
            == "[object Array]";
    };
}
```

`if` 문 안에 선언이 아니라, `function` **표현식**을 놓는 것을 아는 것이 중요하다. 블록 안에 있는 `function` 표현식은 완벽하게 괜찮고 유효하다. FiB에 대한 우리의 논의는 블록 안에서 `function` **선언** 피하기에 대한 것이다.

당신의 프로그램을 테스트하고 그것이 정확히 작동했더라도, 당신의 코드 안에서 FiB 스타일을 사용함으로서 얻을 수 있는 작은 혜택은 (다른 개발자들에 의한 혼란 또는 다른 JS 환경 안에서 당신의 코드를 실행하는 방법의 차이로 인해) 미래의 잠재적인 리스크에 의해 훨씬 더 압박된다.

FiB는 그럴 가치가 없으며, 사용하는 걸 피해야 한다.

:::tip 옮긴이 주
FiB의 작은 혜택(또는 편의)에 비해 미래의 잠재적인 리스크가 더 크다. 따라서 작은 혜택을 선택할 가치가 없고 그것의 사용을 피하라는 뜻
:::

## Blocked Over

프로그래밍 언어에서 렉시컬 스코프 규칙의 핵심은 우리가 의미론적 코드 의사소통 뿐만 아니라 운영적인 목적을 위해서 프로그램의 변수들을 적절히 조직할 수 있다는 것이다.

그리고 가장 중요한 조직적 테크닉 중 하나는 불필요한 스코프에 과노출되는 변수가 없도록 보장하는 것이다(POLE). 희망적이게도 이제 당신은 전보다 더욱 더 깊이 있게 블록 스코핑을 인식한다.

바라건데 지금부터 렉시컬 스코프에 대한 이해를 바탕으로 더욱 더 단단한 땅 위에 서 있는 것처럼 느끼길 바란다. 이것을 기반으로 하여, 다음 챕터는 클로저라는 무거운 주제로 넘어간다.

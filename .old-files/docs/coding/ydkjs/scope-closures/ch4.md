---
date: 2022-01-01
description: 번역 - Chapter 4 - Around the Global Scope
---
# Chapter 4: Around the Global Scope

::: tip
- [You Don't Know JS - 2nd Edition](https://github.com/getify/You-Dont-Know-JS "영문") 깃허브 공개 버전(영문)을 개인의 학습 목적으로 번역합니다.
- 한글 번역을 끝내면 핵심만 정리해 요약본으로 교체할 예정입니다.
- 전문 번역서는 [한빛미디어](https://www.hanbit.co.kr/media/books/book_view.html?p_code=B8227329776)에서 구입할 수 있습니다.
:::

[[toc]]

챕터 3에서 "전역 스코프"를 몇 차례 언급했다. 그러나 당신은 모던 JS 프로그램에서 왜 최상위 스코프가 가장 중요한지 아직 궁금할 것이다. 중요한 작업은 전역보다는 차라리 함수나 모듈 내부에서 일어나지 않는가.

"전역 스코프 사용을 회피하라"고 주장하고 그것을 따르는 것만으로 충분하지 않을까?

JS 프로그램의 전역 스코프는 당신이 추측할 수 있는 것보다 더욱 유용하고 섬세한, 핵심 주제다. 이 챕터는 첫째 전역 스코프는 오늘날 JS 프로그램을 작성하는 것과 얼마나 관계가 있고 여전히 유용한지 알아볼 것이다. 그리고 다른 JS 환경에서 전역 스코프에 접속하는 장소와 방법의 차이점을 살펴볼 것이다.

전역 스코프를 완전히 이해하는 것은 당신이 렉시컬 스코프 사용을 마스터하는 데 대단히 중요하다.

## Why Global Scope?

대부분의 애플리케이션들은 다수의 독립된 JS 파일들로 구성된다는 것이 놀랄 일은 아니다. 그러면 JS 엔진은 어떻게 독립적으로 분리된 JS 파일들을 정확히 하나의 단일 파일 런타임 컨텍스트에 함께 연결해 놓을까?

브라우저에서 실행되는 애플리케이션의 관점에서, 3가지 주요 방법이 있다.

::: tip
[옮긴이 주] 3가지 주요 방법 정리:

1. 첫째 각 파일들을 개별적으로 로딩 - 파일들이 공유하는 참조에 의존해 액세스,
2. 둘째 각 파일들을 번들러로 트랜스파일링하여 단일 인클로징 스코프로 래핑한 뒤 로딩 - 공유되는 스코프 안에서 지역 변수를 통하여 액세스,
3. 셋째 개별적으로 로딩하든 번들러를 이용하든, 단일 인클로징 스코프가 없다면 전역 스코프를 통해 액세스.
:::

첫째, 직접 ES 모듈들을 사용한다면(그것들을 다른 모듈 번들 포맷으로 트랜스파일링 하지 않음), 그 파일들은 JS 환경에 의해 개별적으로 로드된다. 그때 각 모듈은 그것이 액세스할 다른 모듈들에 대한 참조들을 `import` 한다. 그 개별 모듈 파일들은 어떤 공유된 외부 스코프를 요구하지 않고 그 공유된 참조들을 통하여 배타적으로 협력한다.

두번째, 만약 빌드 프로세스를 위해 번들러를 사용한다면, 일반적으로 모든 파일들을 브라우저와 JS 엔진에 전달하기 전 함께 사슬처럼 연결된다. 그때 브라우저와 JS 엔진은 하나의 큰 파일만을 처리한다. 애플리케이션의 모든 부분들이 단일 파일에 모여있더라도, 다음과 같은 메커니즘은 필요하다. 각 부분이 다른 부분들에 의해 참조될 **name**을 등록하고, 그 액세스가 일어나는데 필요한 어떤 기능 역시 등록돼야 한다.

일부 빌드 설정에서 파일의 전체 내용은 래퍼 함수, 유니버셜 모듈(UMD -- 부록 A 참고), 기타 등등과 같은 단일 인클로징 스코프a single enclosing scope로 래핑된다. 각 부분은 공유되는 스코프 안에서 지역 변수를 통하는 방법으로 다른 부분에서 액세스하도록 스스로를 등록할 수 있다. 예를 들어,

``` js
(function wrappingOuterScope(){
  var moduleOne = (function one(){
    // ..
  })();

  var moduleTwo = (function two(){
    // ..

    function callModuleOne() {
      moduleOne.someMethod();
    }

    // ..
  })();
})();
```

보는 바와 같이, `wrappingOuterScope()` 함수 스코프 안의 `moduleOne`과 `moduleTwo` 지역 변수들이 선언되었다. 그래서 이 모듈들은 협업을 위해 서로 액세스할 수 있다.

만일 `wrappingOuterScope()` 스코프가 함수이고 전체 환경의 전역 스코프full environment global scope가 아니라면, 그 함수 스코프는 모든 최상위 식별자들이 저장될 수 있는 버킷처럼 "애플리케이션 전체에 걸친 스코프 application-wide scope"의 한 종류로서 작동한다. 이런 점에서 그 함수의 스코프는 전역 스코프의 대체재와 같은 종류이다.

마지막으로 세번째 방법이다. 번들러 도구를 사용하든 `<script>` 태그나 다른 동적 JS 리소스 로딩을 통해 비 ES 모듈non-ES module을 브라우저에서 개별적으로 간단히 로드하든, 만약 모든 부분들을 둘러싸는 싱글 서라운딩 스코프가 없다면, 그들이 서로 협력하기 위한 방법은 **전역 스코프**가 유일하다.

이 종류의 번들 파일은 종종 아래 예시처럼 쓰인다.

``` js
var moduleOne = (function one(){
  // ..
})();
var moduleTwo = (function two(){
  // ..

  function callModuleOne() {
    moduleOne.someMethod();
  }

  // ..
})();
```

여기, 둘러싸고 있는 함수 스코프가 없기 때문에, `moduleOne`과 `moduleTwo` 선언들은 단순히 전역변수에 위치한다. 이것은 파일들이 개별적으로 로드되는 것을 제외하면 마치 연결돼 있지 않은 상태와 사실상 동일하다.

**module1.js:**

``` js
var moduleOne = (function one(){
  // ..
})();
```

**module2.js:**

``` js
var moduleTwo = (function two(){
  // ..

  function callModuleOne() {
    moduleOne.someMethod();
  }

  // ..
})();
```

만일 이 파일들이 브라우저 환경에서 일반적인 단독 .js 파일들처럼 개별적으로 로드된다면, 각 파일의 최상위 변수 선언은 전역 변수가 될 것이다. JS 엔진 관점에서 그 전역 스코프는 이 두 개의 개별 파일들(이것은 독립적인 프로그램들이다) 사이에서 공유하는 유일한 리소스이기 때문이다.

전역 스코프는, 런타임 중 애플리케이션 코드가 상주하는 위치 그리고 협력을 위해 각 부분이 다른 부분에 접속할 수 있는 방법을 (잠재적으로) 설명할 뿐만 아니라, 또한 다음과 같은 기능을 제공하는 장소이기도 하다.

JS는 (전역 스코프에서) 기본 기능을 제공한다:
  
- primitives: `undefined`, `null`, `Infinity`, `NaN`
- natives: `Date()`, `Object()`, `String()`, etc.
- global functions: `eval()`, `parseInt()`, etc.
- namespaces: `Math`, `Atomics`, `JSON`
- friends of JS: `Intl`, `WebAssembly`

JS 엔진을 호스팅하는 환경은 (전역 스코프에서) 그 자신의 기본 기능을 제공한다.
  
- `console` (과 그것의 메서드들)
- DOM (`window`, `document`, etc.)
- timers (`setTimeout(..)`, etc.)
- web platform APIs: `navigator`, `history`, geolocation, WebRTC, etc.

이것들은 당신의 프로그램과 상호작용할 많은 **globals**중 일부다.

또한, Node는 몇몇 요소들을 **전역적으로globally** 제공한다. 그러나 그 요소들은 기술적으로 `global` 스코프에 있는 것은 아니다: `require()`, `__dirname`, `module`, `URL`, 이외 기타 요소들.

대부분의 개발자들은 전역 스코프가 당신의 애플리케이션의 모든 변수를 모아놓는 투기장이 돼서는 안된다는 데 동의한다. 그것은 곧 발생하기를 기다리고 있는 버그 덩어리들이다. 그러나 전역 스코프가 실제적으로 모든 JS 애플리케이션의 중요한 *접착제glue*라는 사실도 부인할 수 없다.

:::tip 요약
1. 전역 스코프를 경유해 여러 액세스가 교환될 수 있다.
2. 전역 스코프에서 코딩에 필요한 기본 요소가 제공된다.
3. 전역 스코프를 쓰레기장으로 만들지 마라.
:::

## Where Exactly is this Global Scope?

전역 스코프가 어떤 함수나 다른 블록 내부가 아닌 파일의 가장 바깥쪽에 있다는 것은 분명해 보일 수 있다. 그러나 그렇게 간단하지 않다.

:::tip
옮긴이주: 전역 객체와 전역 스코프가 동일하다는 나의 생각은 잘못됐다.
:::

다른 JS 환경은 프로그램들의 스코프들 특히, 전역 스코프를 다르게 다룬다. JS 개발자들는 그것을 모르고 쉽게 오해한다.

### Browser "Window"

전역 스코프 처리와 관련하여, JS가 실행되는 가장 *순수한pure*
환경은 브라우저 내의 웹페이지 환경에서 독립 실행형standalone .js 파일이 로드됐을 때다. 나는, 자동으로 추가되는 것이 아무것도 없을 때 "pure"라고 의미하지 않는다. 실제로 많은 것이 추가된다! 차라리 코드 침입이나 예상되는 전역 스코프 동작으로서 간섭을 최소화하는 관점에서 ("pure"을 의미한다.)
아래 .js 파일을 생각해보자:

``` js
var studentName = "Kyle";

function hello() {
  console.log(`Hello, ${ studentName }!`);
}

hello();
// Hello, Kyle!
```

이 코드는 인라인 `<script>` 태그, 마크업 안의 `<script src=..>` 스크립트 태그, 또는 동적으로 생성되는 `<script>` DOM 요소를 사용하여 웹페이지 환경에서 로드될 것이다. 3 가지 모든 케이스에서, `studentName`과 `hello` 식별자들은 전역 스코프에 선언된다.

만약 당신이 전역 객체(브라우저 환경에서는 `window`)에 액세스한다면, 그들과 같은 이름의 프로퍼티들을 찾을 수 있음을 의미한다.

``` js
var studentName = "Kyle";

function hello() {
  console.log(`Hello, ${ window.studentName }!`);
}

window.hello();
// Hello, Kyle!
```

그것은 JS 명세서 리딩으로 예상할 수 있는 기본 동작이다: 여기서 외부 스코프는 전역 스코프이고 `studentName`은 전역 변수로서 규정에 따라 생성되었다.

그것은 *pure*를 통해 내가 의미하고자 하는 것이다. 그러나 불행히도, 그것은 당신이 마주하는 모든 JS 환경에서 항상 옳지는 않을 것이다. 그것은 종종 JS 개발자들을 놀라게 한다.

:::tip 요약
1. Pure한 환경에서, standalone .js 파일의 가장 바깥의 변수는 전역 변수이고, `window` 전역 객체를 통해 액세스할 수 있다.
2. 그러나 환경에 따라 다를 수 있다.
:::

#### Globals Shadowing Globals

챕터 3의 그림자화(and global unshadowing)를 상기하자, 하나의 변수 선언은 외부 스코프에 존재하는 동일한 이름의 선언을 덮어쓸 수 있고, 접근을 막을 수 있다.

같은 이름의 전역 프로퍼티와 전역 변수 사이의 차이점에서 특히 중요한 한 가지 사실은 전역 스코프 자신 안에서 *전역 객체 프로퍼티는 전역 변수에 의해 그림자화될 수 있다*는 것이다.

``` js
window.something = 42;

let something = "Kyle";
// var로 바꿔보세요

console.log(something);
// Kyle

console.log(window.something);
// 42
```

`let` 선언을 전역 객체 프로퍼티가 아닌 `something` 전역 변수에 추가하자. 그때 `something` 렉시컬 식별자는 `something` 전역 객체 프로퍼티를 그림자화하는 효과가 있다.

전역 객체와 전역 스코프 사이의 틈(차이)을 만드는 것은 확실히 말해 나쁜 생각이다.

전역 선언들로 이 문제를 피하는 간단한 방법은 전역(globals)을 위해 항상 `var`를 사용하는 것이다. 블록 스코프에서는 `let`과 `const`를 유지하자.

:::tip
그동안 전역 스코프와 전역 객체는 동일한 개체라고 막연히 생각했다. 또, 전역 변수와 전역 객체의 프로퍼티도 동일한 개체라고 생각했다. 이것은 완전히 잘못된 생각이다. 계속 공부하다 보면 자세한 힌트를 얻겠지만, 전역 객체의 프로퍼티는 전역 변수를 미러링할뿐 서로 동일체가 아니다. 전역 객체 `window`를 경유해 전역 변수의 값을 얻을 수 있었기에 동일인 개체인 줄 알았다.
:::

#### DOM Globals

브라우저 호스팅된 JS 환경brower-hosted JS environment은 우리가 보게 될 가장 *순수한pure* 전역 스코프 동작을 가졌다고 단언했다. 그러나, 그것은 완전히*순수하지pure* 않다.

브라우저 기반 JS 애플리케이션에서 마주할 전역 스코프의 한 가지 놀라운 동작은 `id` 속성을 가진 DOM 요소는 자동으로 자신을 참조하는 전역 변수를 생성한다는 것이다.

다음 마크업을 생각해보자.

``` html
<ul id="my-todo-list">
  <li id="first">Write a book</li>
  ..
</ul>
```

위 페이지의 JS는 다음을 포함한다.

``` js
first;
// <li id="first>..</li>
window["my-todo-list"];
// <ul id="my-todo-list">..</ul>
```

만약 `id` 값이 `first`처럼 어휘적으로 유효한 이름이라면(변수에 -(하이픈)을 사용할 수 없다), 그 어휘의 변수가 생성된다. 만약 유효하지 않다면, 전역에 접속할 유일한 방법은 전역 객체(`window[..]`)를 경유하는 것뿐이다.

:::tip
어휘적으로 유효하다는 뜻은 변수명 작성 규칙을 어기지 않았다는 뜻과 같다. 특수문자가 사용된 `id="my-toto-list"`는 어휘적으로 유효하지 않기 때문에 변수가 생성되지 않는다. 다만, `window` 객체의 프로퍼티로 접근할 수는 있다.
:::

모든 `id`가 포함된 DOM 요소들을 전역 변수들로 자동 등록하는 것은 오래된 레거시 브라우저old legacy browser의 동작이다. 그럼에도 불구하고 매우 많은 오래된 사이트들은 여전히 그 동작에 의존하기 때문에 해당 동작은 유지되어야 한다. 그 전역 변수가 항상 생성될지라도, 절대 사용하지 말 것을 권한다.

:::tip
편의성이 중요시되던 기존 JS 코딩 관점에서 벗어나 예상치 못한 오류를 방지하는 등의 엄격한 통제를 중요시 여기는 모던 JS 관점에서, 저자는 그 자동 생성 전역 변수를 아예 사용하지 말라고 권하는 듯하다.
:::

#### What's in a (Window) Name?

브라우저 기반 JS에서 또 다른 전역 스코프의 특이함이 있다.

```js
var name = 42;

console.log(name, typeof name);
// "42" string
```

`window.name`은 브라우저 컨텍스트에 사전에 정의된 "global"이다. 다시 말해, 이것은 전역 객체의 프로퍼티이고, 그래서 "일반" 전역 변수처럼 보인다. (그러나 절대 "일반"적이지 않다.)

우리는 선언 시 `var`를 사용한다. 그것은 사전에 정의된 `name` 전역 프로퍼티를 그림자화하지 **않는다**. 이 말의 뜻은 사실상 `var` 선언이 *무시된다*는 뜻인데, 이미 그 이름(`name`)으로 된 전역 스코프 객체 프로퍼티가 존재하기 때문이다. 우리가 앞에서 논의한 것처럼, `let name`을 사용했다면 다른 전역 `name` 변수에 의해 `window.name`은 그림자화됐을 것이다.

그러나 정말 놀라운 행동은 `name`(그리고 `window.name`)에 숫자 `42`를 할당했음에도 불구하고, 그 값을 불러오게되면 그 값은 문자열 `"42"`라는 것이다! 여기서 이런 기묘함은 `name`은 실제로 `window` 객체에 사전 정의된 getter/setter이기 때문이다. 이것은 항상 문자열로 된 값을 반환한다.

DOM 요소 ID와 `window.name`과 같은 몇몇 보기 드문 사례를 제외하고, 브라우저 페이지 내의 독립실행standalone 파일로서 실행되는 JS는 우리가 마주할 가장 *순수한pure* 전역 스코프 동작의 일부를 가지고 있다.

### Web Workers

Web Worker는 브라우저-JS 동작 위에 있는 웹 플랫폼 확장이다. Web Worker는 메인 JS 프로그램을 실행하는 스레드로부터 완전히 분리된 스레드에서 JS 파일을 실행하도록 허용한다.

Web Workder 프로그램은 분리된 스레드에서 실행하기 때문에, 실행 조건을 제한하고 다른 복잡함들을 피하기 위해 그 프로그램은 메인 애플리케이션 스레드와의 소통이 제한된다. 예를 들어, Web Worker의 코드는 DOM에 액세스 하지 않는다. 하지만, 어떤 웹 API는 `navigator`와 같은 woker를 이용할 수 있게 한다.

Web Worker는 완전히 분리된 프로그램으로 취급되기 때문에, 그것은 메인 JS 프로그램과 전역 스코프를 공유하지 않는다. 하지만, 브라우저의 JS 엔진은 그 코드를 계속 실행하고 있고, 그래서 우리는 전역 스코프 동작의 유사한 *순수성purity*을 기대할 수 있다. DOM 접속 권한이 없기 때문에, 전역 스코프를 위한 `window` 별칭은 존재하지 않는다.

Web Worker에서, 전역 객체 참조는 일반적으로 `self`를 이용해 이루어진다.

``` js
var studentName = "Kyle";
let studentID = 42;

function hello() {
    console.log(`Hello, ${ self.studentName }!`);
}

self.hello();
// Hello, Kyle!

self.studentID;
// undefined
```

메인 JS 프로그램들에서처럼, `var`와 `function` 선언들은 일명 `self`라는 전역 객체에 자기를 미러링하는 프로퍼티들을 생성한다. 다른 선언들(`let` 등등)은 `self`에 그런 프로퍼티를 생성하지 않는다.

다시 말해, 우리가 여기서 보는 전역 스코프 동작은 JS 프로그램들이 실행하는 동안 얻는 것만큼 *순수*하다. 오히려 그것은 DOM이 남기는 것들이 없기 때문에 심지어 더 *순수*하다.

### Developer Tools Console/REPL

*Get Started*의 1장을 상기해 보자. 개발자 도구는 완전히 지원하는 JS 환경을 생성하지 않는다. 개발자 도구는 JS 코드를 처리하지만, 일명 개발자 환경 또는 DX로 알려진 개발자들에게 가장 친숙한 UX 상호작용을 선호한다.

몇몇 경우에 있어 전체 JS 프로그램을 처리할 때 기대되는 일반적으로 엄격한 단계를 넘어, JS 스니펫을 타이핑할 때 DX를 선호하는 것은 프로그램들과 도구들 간의 코드 동작의 명백한 차이들을 만든다. 예를 들어, JS 프로그램에 적용할 수 있는 특정 오류 조건이 완화되고, 개발자 도구에 코드가 입력될 때 (그 오류가) 나타나지 않을 수 있다.

스코프에 대한 우리의 논의에 비추어, 다음과 같이 관찰할 수 있는 동작의 차이점을 포함할 것이다.
- 전역 스코프의 동작
- 호이스팅 (5장을 보세요)
- 가장 바깥의 스코프에서 사용될 때 블록 스코프 선언 (`let` / `const`, 6장을 보세요)

콘솔/REPL을 사용할 때, 가장 바깥 스코프outermost scope에 입력된 코드는 실제 전역 스코프real global scope 내에서 처리되고 있는 것처럼 보일지 모르더라도, 정확한 것은 아니다. 그와 같은 도구들은 일반적으로 확장을 위해 전역 스코프 위치를 흉내낸다. 그것은 엄격한 호환adherence이 아닌 에뮬레이션이다. 이 도구 환경은 개발자 편의성을 우선시한다. 이것은 때때로 (예를 들어, 스코프에 관한 우리의 현재 논의에 있어) 관찰된 동작이 JS 명세서에서 벗어날 수 있다.

결론적으로 개발자 도구들은 다양한 개발자 활동의 유용성과 편의성에 최적화된 반면 실제 JS 프로그램 컨텍스트의 분명하고 미묘한 동작을 확인하거나 판단하기에 적합한 환경들은 아니다.

### ES Modules (ESM)

ES6는 모듈 패턴을 위한 일급 클래스의 지원을 소개했다(8장에서 다룬다). ESM 사용의 가장 분명한 효과들 중 하나는 어떻게 ESM이 한 파일에서 관찰할 수 있는 최상위 스코프의 동작을 변경하느냐이다.

앞서 본 코드 스니펫을 생각해보자. (`export` 키워드를 사용해 ESM 포맷을 적용할 것이다.)

```js
var studentName = "Kyle";

function hello() {
    console.log(`Hello, ${ studentName }!`);
}

hello();
// Hello, Kyle!

export hello;
```

만약 그 코드가 ES 모듈로 로드되는 파일 안에 있다면, 정확히 동일하게 실행할 것이다. 그러나, 전체 애플리케이션 관점에서 관찰할 수 있는 효과들은 다를 것이다.

(모듈) 파일의 최상위에 선언됐음에도 불구하고, 가장 바깥이 분명한 스코프에 있는 `studentName`과 `hello`는 전역 변수들이 아니다. 대신 이것들은 mudule-wide 또는 "module-global"이다.

그러나, 선언들이 모듈이 아닌 JS 파일들의 최상위에 있을 때와 마찬가지로, 모듈 안에서 프로퍼티들로서 추가된 최상위 선언들을 위한 암시적 "모듈 범위의 전역 스코프 객체module-wide scope object"는 없다. 이것은 전역 변수들이 존재할 수 없거나 그와 같은 프로그램들 안에서 액세스될 수 없음을 말하려는 것이 아니다. **전역 변수들은 모듈의 최상위 스코프 안 변수 선언에 의해 생성되지 않는다**는 말이다.

마치 모듈의 전체 내용이 한 함수 안에 래핑되는 것처럼, 모듈의 최상위 스코프는 전역 스코프의 자손이다. 게다가, (전역 객체 안에 있든 없든 간에) **전역 스코프 안에 존재하는 모든 변수들은 모듈의 스코프 안에서 렉시컬 식별자들처럼 이용할 수 있다.**

**전역 스코프는 현 모듈을 실행하는데 필요할 수 있는 모든 모듈을 가져오는데, ESM은 그 전역 스코프에 대한 의존성의 최소화를 돕는다.** 따라서, 전역 스코프 또는 해당 전역 객체의 사용량이 감소한다.

그러나, 앞서 언급한 것처럼, 당신이 알든 모르든 전역 스코프에 액세스를 지속할 웹 글로벌web globals과 JS가 여전히 많다.

### Node

Node가 JS 개발자들의 부주의를 부르는 한 측면은, Node는 로드 시 (Node 프로세스 시작 시 실행하는 메인 파일을 포함하여) 모든 단일 .js 파일을 모듈처럼 처리한다는 점이다(ES 모듈 또는 CommonJS 모듈, 챕터 8 참고). 실질적으로 Node 프로그램의 최상위는 브라우저에서 모듈이 아닌 파일을 로딩할 때 그런 것처럼 **전역 스코프가 절대 아니다**.

이 글을 쓸 때부터, Node는 최근 ES 모듈을 지원하고 있다. 그러나 노드는 초기부터 "CommonJS"로 알려진 모듈 포맷을 추가적으로 지원하고 있다. 다음을 보자.

```js
var studentName = "Kyle";

function hello() {
    console.log(`Hello, ${ studentName }!`);
}

hello();
// Hello, Kyle!

module.exports.hello = hello;
```

**프로세싱 전, Node는 함수 안의 코드를 효과적으로 래핑한다.** 그래서 `var`와 `function` 선언들은 전역 변수들처럼 처리되지 않고 래핑된 함수의 스코프에 포함된다.

아래 코드처럼 Node에 의해 하나의 함수가 앞서 제시된 코드를 래핑했다고 생각해 보자.(실제로 그렇지는 않지만 아래 묘사된)

```js
function Module(module,require,__dirname,...) {
    var studentName = "Kyle";

    function hello() {
        console.log(`Hello, ${ studentName }!`);
    }

    hello();
    // Hello, Kyle!

    module.exports.hello = hello;
}
```

이때 Node는 모듈을 실행하기 위해 추가된 `Module(..)` 함수를 필수적으로 호출한다. 여기서 `studentName`과 `hello` 식별자들은 전역이 아닌 오히려 모듈 스코프 안에 선언된 이유를 명확히 이해할 수 있다.

앞서 언급한 것처럼, Node는 `require()`와 같은 많은 "globals"을 정의한다. 그러나 그것들은 실제로 전역 스코프의 식별자들이 아니다(또는 전역 객체의 프로퍼티들이 아니다). 그것들은 모든 모듈의 스코프 안에 주입되고, 기본적으로 `Module(..)` 함수 선언 안에 열거된 매개 변수들과 조금 비슷하다.

그럼, 어떻게 Node에서 실제 전역 변수들을 정의할까? 그러기 위한 유일한 방법은 기본으로 제공되는 Node의 "globals" 중 어느 하나에 프로퍼티를 추가하는 것이다. 이는 역설적으로 `global`이라 불린다. `global`은 브라우저 JS 환경에서 `window`를 사용하는 것처럼 실제 전역 스코프 객체를 참조한다.

다음을 보자:

```js
global.studentName = "Kyle";

function hello() {
    console.log(`Hello, ${ studentName }!`);
}

hello();
// Hello, Kyle!

module.exports.hello = hello;
```

여기 `global` 객체의 프로퍼티로 `studentName`을 추가한다. 그러면 `console.log(..)` 문에서 일반 전역 변수인 `studentname`에 액세스할 수 있다.

식별자 `global`은 JS에 의해 정의되지 않고 특별히 Node에 의해 정의된다는 것을 기억하자.

## Global This

지금까지 본 JS 환경을 재검토하면, 프로그램은 다음과 같을 수도 있고 아닐 수도 있다.

- `var` 또는 `function` 선언들(또는 `let`, `const`, and `class`)로 최상위 스코프에서 전역 변수를 선언한다.
- 또한, `var` 또는 `function`이 선언을 위해 사용되어진다면, 전역 변수 선언을 전역 스코프 객체의 프로퍼티로 추가한다.
- `window`, `self`, 또는 `global`으로 (프로퍼티로서 전역 변수들을 추가하거나 불러오기 위해) 전역 스코프 객체를 참조한다.

전역 객체 액세스와 동작은 대부분의 개발자들이 앞 섹션이 묘사한것처럼 가정하는 것보다는 더 복잡하다. 그러나 그 복잡성은 전역 스코프 객체에 보편적으로 적용할 수 있는 참조로 구체화할 때보다 더 명확하다고 절대 말할 수 없다.

전역 스코프 객체를 참조를 얻기 위한 또 다른 "트릭"은 다음과 같다.

```js
const theGlobalScopeObject =
    (new Function("return this"))();
```

:::tip Note
`eval(..)`과 유사하게 `Function()`의 constructor를 이용하면 문자열 값으로 저장된 코드로부터 함수를 동적으로 생성할 수 있다. (챕터 1 "Cheating: Runtime Scope Modifications" 참조) 그와 같은 함수는 위 코드에서 보는 바와 같이 보통의 `()` 즉시 실행 함수로 호출될 때 (레거시 때문에) 비 엄격 모드에서 자동으로 실행될 것이다. 여기서 `this`는 전역 객체를 가리킬 것이다. `this` 바인딩에 대해 더 많은 정보를 알고 싶으면 이 시리즈의 3번째 책 *Objects & Classes*를 참고하라.
:::

이렇게 우리는 `window`, `self`, 그리고 보기 싫은 `new Function(..)` 트릭이 있다. 이러한 전역 객체를 얻기 위해 시도할 수 있는 다양한 방법들이 많이 있는데, 각각은 장단점을 가지고 있다.

왜 아직 다른 방법들을 소개하지 않는가!?!?

ES2020부터, JS는 마침내 `globalThis`라는 전역 스코프 객체에 대한 표준화된 참조를 정의했다. 그래서, 당신의 코드가 최신 JS 엔진에서 실행된다는 조건에서, 다른 전역 객체 접근법을 대신해 `globalThis`를 사용할 수 있다.

심지어 이전의 `globalThis` JS 환경을 지나 다음과 같이 더 안전한 교차 환경 폴리필을 정의할 수도 있다.

```js
const theGlobalScopeObject =
    (typeof globalThis != "undefined") ? globalThis :
    (typeof global != "undefined") ? global :
    (typeof window != "undefined") ? window :
    (typeof self != "undefined") ? self :
    (new Function("return this"))();
```

Phew! 확실히 이것은 이상적이지 않지만, 신뢰할 수 있는 전역 스코프 참조가 필요할 경우 효과적이다.

(JS에 제시된 이름 `globalThis`가 추가될 때 꽤 논란이 있었다. 특히, 나와 많은 다른 사람들은 그 이름에 있는 "this" 참조는 오해를 부를 수 있다고 느꼈다. 이 객체를 참조하는 이유는 전역/기본global/default `this` 바인딩의 한 종류에 액세스하는 게 절대 아니라 전역 변수에 액세스하는 것이기 때문이다. 다른 이름들도 고려됐지만, 다양한 이유들 때문에 제외됐다. 불행히도, 선택된 그 이름이 최종안a last resort으로 결정됐다. 만약 당신의 프로그램들에서 전역 스코프 객체와 상호작용할 계획이 있다면, 혼동을 줄이기 위해 여기서 사용하는 `theGlobalScopeObject`와 같은 더 나은 이름을 선택하길 강력히 권장한다. 너무 길지만 정확한 의미를 전달한다.)

## Globally Aware

모듈의 체계적인 코드를 위한 *모던 패턴들*은 해당 네임스페이스namespace 안에 저장된 식별자들에 대한 *의존성을 크게 강조하지 않음*에도 불구하고, 전역 스코프는 모든 JS 프로그램 안에 존재하고 관련이 있다.

우리의 코드가 브라우저의 경계를 넘어 더욱 더 확산할 때, 특히 상이한 JS 환경들에서 전역 스코프(와 전역 스코프 객체)가 동작하는 방법의 차이들에 대해 굳은 확신을 가지는 것이 중요하다.

지금은 전역 스코프의 큰 그림에 더욱 집중해야 한다. 다음 챕터는, 변수들이 사용되는 시기와 방법을 분석하여, 다시 렉시컬 스코프의 더 깊은 상세 내용으로 내려간다.
